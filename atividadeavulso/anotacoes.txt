
TreeRedBlackNode *rotacaoEsquerda(TreeRedBlackNode *no);


Cria uma variável auxiliar chamada aux, que aponta para o filho direito do nó recebido. Esse nó será o novo nó que ocupará a posição do nó recebido após a rotação.
Faz o filho direito do nó recebido apontar para o filho esquerdo do auxiliar. Esse nó será o novo filho direito do nó recebido após a rotação.
Verifica se o filho esquerdo do auxiliar é diferente de nulo. Se for, faz o pai do filho esquerdo do auxiliar apontar para o nó recebido. Isso mantém a relação de pai e filho entre os nós da árvore.
Faz o pai do auxiliar apontar para o pai do nó recebido. Isso mantém a relação de pai e filho entre o auxiliar e o avô do nó recebido.
Verifica se o pai do nó recebido é nulo. Se for, significa que o nó recebido era a raiz da árvore, e portanto o auxiliar passa a ser a nova raiz da árvore. Nesse caso, faz o pai do nó recebido apontar para o auxiliar.
Verifica se o nó recebido é igual ao filho esquerdo do pai do nó recebido. Se for, significa que o nó recebido era o filho esquerdo do seu pai, e portanto o auxiliar passa a ser o novo filho esquerdo do pai do nó recebido. Nesse caso, faz o filho esquerdo do pai do nó recebido apontar para o auxiliar.
Se não for nenhum dos casos anteriores, significa que o nó recebido era o filho direito do seu pai, e portanto o auxiliar passa a ser o novo filho direito do pai do nó recebido. Nesse caso, faz o filho direito do pai do nó recebido apontar para o auxiliar.
Faz o filho esquerdo do auxiliar apontar para o nó recebido. Esse nó será o novo filho esquerdo do auxiliar após a rotação.
Faz o pai do nó recebido apontar para o auxiliar. Isso mantém a relação de pai e filho entre o nó recebido e o auxiliar.
Retorna o auxiliar como o novo nó que ocupa a posição do nó recebido.




==================================================

/* ===========================rotacoes============================= */

/* 
▷ Rotação simples à esquerda passa a se chamar rotação
para a direita;
▷ Rotação simples à direita passa a se chamar rotação para a
esquerda; 
*/

/* TreeRedBlackNode *rotacaoEsquerda(TreeRedBlackNode *no) 
{
    TreeRedBlackNode *aux = no->dir; // auxiliar recebe o filho direito do no recebido
    no->dir = aux->esq; // filho direito do no recebe o filho esquerdo do auxiliar
    if (aux->esq != NULL) // se o filho esquerdo do auxiliar for diferente de nulo
    {
        aux->esq->pai = no; // o pai do filho esquerdo do auxiliar recebe o no
    }
    aux->pai = no->pai; // o pai do auxiliar recebe o pai do no
    if (no->pai == NULL) // se o pai do no for nulo
    {
        no->pai = aux; // o pai do no recebe o auxiliar
    }
    else if (no == no->pai->esq) // se o no for igual ao filho esquerdo do pai do no
    {
        no->pai->esq = aux; // o filho esquerdo do pai do no recebe o auxiliar
    }
    else // se não
    {
        no->pai->dir = aux; // o filho direito do pai do no recebe o auxiliar
    }
    aux->esq = no; // o filho esquerdo do auxiliar recebe o no
    no->pai = aux; // o pai do no recebe o auxiliar
    return aux; // retorna o auxiliar
} */



==========================================================================
TreeRedBlack.c 



rotacoes esquerda:

Caso 1e (esquerda) linha 101
- V possui um tio rubro e seu pai é um filho rubro da esquerda
- Não importa se v é um filho da esquerda ou direita
- recolorimos o pai, avô e tio de v
- Se o bisavô de v for negro está concluido
- caso contrário:
- v é elevado a dois níveis
- executamos um passo-CE para o novo v (avô de v original)


Caso 2de (direita-esquerda) linha 116
- V é um filho da direita, cujo pai é um filho rubro da esquerda e cujo tio é 
negro
- Rotacionamos para a esquerda v e seu pai 
- Atualizamos o nó corrente
- O caso 2 (inserção) sempre é sucedido pelo caso 3
- o caso 3 pode ocorrer sozinho


Caso 3e (esquerda) linha 121
- V é um filho da esquerda, cujo pai é um filho rubro da esquerda e cujo tio 
é negro
- Rotacionamos para a direita entre o avô e o pai
- Recolorimos o pai e o avô
- pai fica negro
- avô fica rubro

Caso 2ed (esquerda-direita) linha 141
- V é um filho da esquerda, cujo pai é um filho rubro da direita e cujo tio é 
negro
- Rotacionamos para a direita v e seu pai
- Atualizamos o nó corrente
- Caímos no caso 3

Caso 3d (direita) linha 149
- V é um filho da direita, cujo pai é um filho rubro da direita e cujo tio é 
negro
- Rotacionamos para a esquerda entre o avô e o pai
- Recolorimos o pai e avô
- pai fica negro 
- avô fica rubro


===============================REMOCAO==================================

void removerNo(rbtree *arvore, int id) {
    TreeRedBlackNode *no = buscarNo(arvore, id); // buscando o no que vai ser removido
    if (no == NULL) {
        printf("O no %d nao existe na arvore.\n", id);
        return;
    }
    TreeRedBlackNode *aux = no; // criando um no auxiliar que vai ser o no que vai ser removido
    int corOriginal = aux->cor; // criando uma variavel que vai ser a cor original do no que vai ser removido
    TreeRedBlackNode *aux2; // criando um no auxiliar 2
    if (no->esq == NULL) // se o filho esquerdo do no que vai ser removido for nulo
    {
        aux2 = no->dir; // o no auxiliar 2 recebe o filho direito do no que vai ser removido
        transplantar(arvore, no, no->dir); // chamando a funcao para transplantar a arvore
    }
    else if (no->dir == NULL) // se o filho direito do no que vai ser removido for nulo
    {
        aux2 = no->esq; // o no auxiliar 2 recebe o filho esquerdo do no que vai ser removido
        transplantar(arvore, no, no->esq); // chamando a funcao para transplantar a arvore
    }
    else // se o no que vai ser removido tiver dois filhos
    {
        aux = minimo(no->dir); // o no auxiliar recebe o no minimo do filho direito do no que vai ser removido
        corOriginal = aux->cor; // a cor original do no que vai ser removido recebe a cor do no auxiliar
        aux2 = aux->dir; // o no auxiliar 2 recebe o filho direito do no auxiliar
        if (aux->pai == no) // se o pai do no auxiliar for o no que vai ser removido
        {
            if (aux2 != NULL) // se o no auxiliar 2 for diferente de nulo
            {
                aux2->pai = aux; // o pai do no auxiliar 2
            }
        }
        else // se o pai do no auxiliar nao for o no que vai ser removido
        {
            transplantar(arvore, aux, aux->dir); // chamando a funcao para transplantar a arvore
            aux->dir = no->dir; // o filho direito do no auxiliar recebe o filho direito do no que vai ser removido
            aux->dir->pai = aux; // o pai do filho direito do no auxiliar recebe o no auxiliar
        }
        transplantar(arvore, no, aux); // chamando a funcao para transplantar a arvore
        aux->esq = no->esq; // o filho esquerdo do no auxiliar recebe o filho esquerdo do no que vai ser removido
        aux->esq->pai = aux; // o pai do filho esquerdo do no auxiliar recebe o no auxiliar
        aux->cor = no->cor; // a cor do no auxiliar recebe a cor do no que vai ser removido
    }
    if (corOriginal == BLACK) // se a cor original do no que vai ser removido for preta
    {
        removerFixup(arvore, aux2); // chamando a funcao para corrigir a arvore
    }
    arvore->tam--; // o tamanho da arvore diminui
    free(no); // liberando a memoria do no que foi removido
}








================================
void removerNo(rbtree *arvore, int id)
{
    TreeRedBlackNode *no = buscarNo(arvore, id); // criando um no que vai receber o no que o usuario quer remover
    TreeRedBlackNode *aux = NULL; // criando um no auxiliar que vai ser nulo
    TreeRedBlackNode *aux2 = NULL; // criando um no auxiliar 2 que vai ser nulo
    if (no == NULL) // se o no que o usuario quer remover for nulo
    {
        printf("O no %d nao existe na arvore!\n", id); // mensagem de erro
        return; // retornando
    }
    if (no->esq == NULL || no->dir == NULL) // se o filho esquerdo do no que o usuario quer remover for nulo ou o filho direito do no que o usuario quer remover for nulo
    {
        aux = no; // o no auxiliar recebe o no que o usuario quer remover
    }
    else // se o filho esquerdo do no que o usuario quer remover nao for nulo e o filho direito do no que o usuario quer remover nao for nulo
    {
        aux = no->dir; // o no auxiliar recebe o filho direito do no que o usuario quer remover
        while (aux->esq != NULL) // enquanto o filho esquerdo do no auxiliar for diferente de nulo
        {
            aux = aux->esq; // o no auxiliar recebe o filho esquerdo do no auxiliar
        }
    }
    if (aux->esq != NULL) // se o filho esquerdo do no auxiliar for diferente de nulo
    {
        aux2 = aux->esq; // o no auxiliar 2 recebe o filho esquerdo do no auxiliar
    }
    else // se o filho esquerdo do no auxiliar for nulo
    {
        aux2 = aux->dir; // o no auxiliar 2 recebe o filho direito do no auxiliar
    }
    if (aux2 != NULL) // se o no auxiliar 2 for diferente de nulo
    {
        aux2->pai = aux->pai; // o pai do no auxiliar 2 recebe o pai do no auxiliar
    }
    if(aux->pai == NULL) // se o pai do no auxiliar for nulo
    {
        arvore->raiz = aux2; // a raiz da arvore recebe o no auxiliar 2
    }
    else if(aux == aux->pai->esq) // se o no auxiliar for igual ao filho esquerdo do pai do no auxiliar
    {
        aux->pai->esq = aux2; // o filho esquerdo do pai do no auxiliar recebe o no auxiliar 2
    }
    else // se o no auxiliar for igual ao filho direito do pai do no auxiliar
    {
        aux->pai->dir = aux2; // o filho direito do pai do no auxiliar recebe o no auxiliar 2
    }
    if(aux != no) // se o no auxiliar for diferente do no que o usuario quer remover
    {
        no->id = aux->id; // o id do no que o usuario quer remover recebe o id do no auxiliar
    }
    if(aux->cor == BLACK) // se a cor do no auxiliar for preta
    {
        removerFixup(arvore, aux2); // chamando a funcao para corrigir a arvore
    }
    free(aux); // liberando a memoria do no auxiliar
    arvore->tam--; // o tamanho da arvore diminui
}


void printarNos(TreeRedBlackNode *no){
    if (no != NULL) // se o no for diferente de nulo
    {
        //no print deve haver quem é o pai e quem sao os filhos (caso tenham, print o id)
        printf("No: %d, Cor: %s, Pai: %d, Filho Esquerdo: %d, Filho Direito: %d\n", no->id, (no->cor == RED) ? "Vermelho (RED)" : "Preto (BLACK)", (no->pai != NULL) ? no->pai->id : -1, (no->esq != NULL) ? no->esq->id : -1, (no->dir != NULL) ? no->dir->id : -1);
        printarNos(no->esq); // chamando a funcao para printar os nos da arvore esquerda
        printarNos(no->dir); // chamando a funcao para printar os nos da arvore direita
    }
}



notas sobre remocao:

1) Se o nó a ser excluído não tiver filhos, basta removê-lo e atualizar o nó pai.
2) Se o nó a ser excluído tiver apenas um filho, substitua o nó por seu filho.
3) Se o nó a ser excluído tiver dois filhos, substitua o nó por seu sucessor na ordem, que é o nó mais à esquerda na subárvore direita. Em seguida, exclua o nó sucessor em ordem como se ele tivesse no máximo um filho.
4) Depois que o nó for excluído, as propriedades rubro-negras poderão ser violadas. Para restaurar essas propriedades, algumas alterações de cor e rotações são executadas nos nós da árvore. As alterações são semelhantes às realizadas durante a inserção, porém com condições diferentes.
5)A operação de exclusão em uma árvore rubro-negra leva O(log n) tempo em média, tornando-se uma boa opção para pesquisar e excluir elementos em grandes conjuntos de dados.


exlucao:

Caso 1 - irmão do nó é vermelho
● Pai fica vermelho
● Irmão (nó direito) fica preto
● Rotação à esquerda do pai

Resultado caso 1 : preparou para Caso 2 : irmão da direita é preto e filhos são pretos
● Irmão direito fica vermelho
● Sobe na árvore para testar próximos casos
Resultado caso 2 : novo nó é vermelho, retorna do algoritmo e seta para preto
Ajustando a árvore para os demais casos
● Irmão (nó direito) fica preto
● Rotação à esquerda do pai
Caso 3: irmão da direita é preto, filho direito do irmão é preto e filho esquerdo é vermelho:
Irmão direito fica vermelho
Filho esquerdo fica preto
Rotação à direita do irmão esquerdo
Caso 4: Irmão da direita é preto, e filho direito é vermelho
Nó
Irmão direito
Filho direito
● Nó da direita fica com a cor do pai
● Nó pai fica preto
● Filho direito fica preto
● Rotaciona pai à esquerda














void removerNo(rbtree *arvore, int id) {
    TreeRedBlackNode *no = buscarNo(arvore, id);
    if (no == NULL) {
        printf("O no %d nao existe na arvore!\n", id);
        return;
    }

    TreeRedBlackNode *aux = no;
    TreeRedBlackNode *aux_pai = NULL; // Adicionando um ponteiro para o pai do nó auxiliar

    // Definindo o nó a ser removido
    if (no->esq == NULL || no->dir == NULL)
        aux = no;
    else {
        aux = no->dir;
        while (aux->esq != NULL)
            aux = aux->esq;
    }

    // Atualizando o ponteiro do pai do nó auxiliar
    aux_pai = aux->pai;

    // Definindo o nó auxiliar 2 que será o filho não nulo de aux
    TreeRedBlackNode *aux2 = (aux->esq != NULL) ? aux->esq : aux->dir;

    // Atualizando o pai de aux2, se existir
    if (aux2 != NULL)
        aux2->pai = aux_pai;

    // Atualizando a raiz da árvore, se necessário
    if (aux_pai == NULL)
        arvore->raiz = aux2;
    else if (aux == aux_pai->esq)
        aux_pai->esq = aux2;
    else
        aux_pai->dir = aux2;

    // Se aux é diferente de no, então copie o conteúdo de aux para no
    if (aux != no)
        no->id = aux->id;

    // Se a cor de aux é preta, chame a função de correção
    if (aux->cor == BLACK)
        removerFixup(arvore, aux2, aux_pai);

    // Liberando memória
    free(aux);
    arvore->tam--;
}

void removerFixup(rbtree *arvore, TreeRedBlackNode *no, TreeRedBlackNode *pai) {
    while (no != arvore->raiz && (no == NULL || no->cor == BLACK)) {
        if (no == pai->esq) {
            TreeRedBlackNode *irmao = pai->dir;
            if (irmao->cor == RED) {
                printf("O irmao do no %d e vermelho\n", no->id);
                irmao->cor = BLACK;
                printf("O irmao do no %d foi pintado de preto\n", no->id);
                pai->cor = RED;
                printf("O pai do no %d foi pintado de vermelho\n", no->id);
                printf("rotaciono o pai a esquerda\n");
                rotacaoEsquerda(arvore, pai);
                irmao = pai->dir;
            }
            if ((irmao->esq == NULL || irmao->esq->cor == BLACK) &&
                (irmao->dir == NULL || irmao->dir->cor == BLACK)) {
                irmao->cor = RED;
                printf("O irmao do no %d foi pintado de vermelho\n", no->id);
                no = pai;
                printf("O no %d recebeu o pai\n", no->id);
                pai = no->pai;
                printf("O pai do no %d recebeu o pai do no %d\n", no->id, no->id);
            } else {
                if (irmao->dir == NULL || irmao->dir->cor == BLACK) {
                    if (irmao->esq != NULL)
                        irmao->esq->cor = BLACK;
                        printf("O filho esquerdo do irmao do no %d foi pintado de preto\n", no->id);
                    irmao->cor = RED;
                    printf("O irmao do no %d foi pintado de vermelho\n", no->id);
                    printf("rotaciono o irmao a direita\n");
                    rotacaoDireita(arvore, irmao);
                    irmao = pai->dir;
                }
                irmao->cor = pai->cor;
                printf("O irmao do no %d recebeu a cor do pai\n", no->id);
                pai->cor = BLACK;
                printf("O pai do no %d foi pintado de preto\n", no->id);
                if (irmao->dir != NULL)                     // Se o irmão tiver um filho direito
                    irmao->dir->cor = BLACK;
                    printf("O filho direito do irmao do no %d foi pintado de preto\n", no->id);
                printf("rotaciono o pai a esquerda\n");
                rotacaoEsquerda(arvore, pai);
                no = arvore->raiz;
            }
        } else {
            TreeRedBlackNode *irmao = pai->esq;
            if (irmao->cor == RED) {
                irmao->cor = BLACK;
                printf("O irmao do no %d foi pintado de preto\n", no->id);
                pai->cor = RED;
                printf("O pai do no %d foi pintado de vermelho\n", no->id);
                printf("rotaciono o pai a direita\n");
                rotacaoDireita(arvore, pai);
                irmao = pai->esq;
            }
            if ((irmao->dir == NULL || irmao->dir->cor == BLACK) &&        
                (irmao->esq == NULL || irmao->esq->cor == BLACK)) {         // Se o irmão não tiver filhos ou ambos forem pretos & irmão for preto
                irmao->cor = RED;
                printf("O irmao do no %d foi pintado de vermelho\n", no->id);
                no = pai;
                printf("O no %d recebeu o pai\n", no->id);
                pai = no->pai;
                printf("O pai do no %d recebeu o pai do no %d\n", no->id, no->id);
            } else {
                if (irmao->esq == NULL || irmao->esq->cor == BLACK) {       // Se o irmão não tiver um filho esquerdo ou o filho esquerdo for preto
                    if (irmao->dir != NULL)
                        irmao->dir->cor = BLACK;
                    irmao->cor = RED;
                    printf("O irmao do no %d foi pintado de vermelho\n", no->id);
                    printf("rotaciono o irmao a esquerda\n");
                    rotacaoEsquerda(arvore, irmao);
                    irmao = pai->esq;
                }
                irmao->cor = pai->cor;
                printf("O irmao do no %d recebeu a cor do pai\n", no->id);
                pai->cor = BLACK;
                if (irmao->esq != NULL)                    // Se o irmão tiver um filho esquerdo
                    irmao->esq->cor = BLACK;
                    printf("O filho esquerdo do irmao do no %d foi pintado de preto\n", no->id);
                printf("rotaciono o pai a direita\n");
                rotacaoDireita(arvore, pai);

                no = arvore->raiz; // O nó recebe a raiz da árvore
            }
        }
    }
    if (no != NULL)                 // Se o nó for diferente de nulo
        no->cor = BLACK;
}